// git_manager.rs
use std::process::{Command, Stdio};
use std::fs;
use crate::ansi_theme::AnsiTheme;
use crate::config::ThemeConfig;

pub struct GitManager {
    config: crate::config::AppConfig,
}

impl GitManager {
    pub fn new_with_config(config: crate::config::AppConfig) -> Self {
        GitManager { config }
    }

    pub fn new() -> Self {
        let config_manager = crate::config::ConfigManager::new();
        GitManager { 
            config: config_manager.get_config().clone()
        }
    }

    pub fn is_git_initialized(&self, project_name: &str) -> bool {
        let project_path = self.config.get_project_path(project_name);
        let git_dir = project_path.join(".git");
        git_dir.exists() && git_dir.is_dir()
    }

    pub fn initialize_git(&self, project_name: &str, theme: &ThemeConfig) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if self.is_git_initialized(project_name) {
            return Err("Git repository already initialized".to_string());
        }

        AnsiTheme::print_themed(&format!("Initializing Git repository for: {}\n", project_name), theme);
        
        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("init")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to initialize git repository: {}", e))?;

        if output.status.success() {
            AnsiTheme::print_success(" Git repository initialized successfully\n", theme);
            
            // Create initial .gitignore for Rust projects
            self.create_gitignore(project_name, theme)?;
            
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to initialize git: {}", stderr))
        }
    }

    fn create_gitignore(&self, project_name: &str, theme: &ThemeConfig) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        let gitignore_path = project_path.join(".gitignore");
        
        let gitignore_content = r#"# Generated by Rust Dev Terminal
/target/
**/*.rs.bk
Cargo.lock

# Remove Cargo.lock if you're building a library
# Cargo.lock

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
Thumbs.db"#;

        fs::write(&gitignore_path, gitignore_content)
            .map_err(|e| format!("Failed to create .gitignore: {}", e))?;
        
        AnsiTheme::print_success(" Created .gitignore file\n", theme);
        Ok(())
    }

    pub fn get_status(&self, project_name: &str) -> Result<GitStatus, String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("status")
            .arg("--porcelain")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to get git status: {}", e))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Failed to get git status: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let files: Vec<GitFileStatus> = stdout
            .lines()
            .filter_map(|line| {
                if line.len() >= 4 {
                    let status = &line[0..2];
                    let file_path = &line[3..];
                    Some(GitFileStatus {
                        status: status.trim().to_string(),
                        file_path: file_path.to_string(),
                    })
                } else {
                    None
                }
            })
            .collect();

        // Get current branch
        let branch_output = Command::new("git")
            .current_dir(&project_path)
            .arg("branch")
            .arg("--show-current")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to get current branch: {}", e))?;

        let current_branch = if branch_output.status.success() {
            String::from_utf8_lossy(&branch_output.stdout).trim().to_string()
        } else {
            "unknown".to_string()
        };

        Ok(GitStatus {
            files: files.clone(),
            current_branch,
            has_changes: !files.is_empty(),
        })
    }

    pub fn add_files(&self, project_name: &str, files: &[String]) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let mut command = Command::new("git");
        command.current_dir(&project_path).arg("add");
        
        for file in files {
            command.arg(file);
        }

        let output = command
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to add files: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to add files: {}", stderr))
        }
    }

    pub fn add_all(&self, project_name: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("add")
            .arg(".")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to add all files: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to add all files: {}", stderr))
        }
    }

    pub fn commit(&self, project_name: &str, message: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("commit")
            .arg("-m")
            .arg(message)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to commit: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to commit: {}", stderr))
        }
    }

    pub fn push(&self, project_name: &str, remote: &str, branch: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("push")
            .arg("-u") // Set upstream
            .arg(remote)
            .arg(branch)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to push: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            
            // If push fails due to no commits, try with --all
            if stderr.contains("does not match any") {
                return self.initial_push(project_name, remote, branch);
            }
            
            Err(format!("Failed to push: {}", stderr))
        }
    }

    fn initial_push(&self, project_name: &str, remote: &str, branch: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("push")
            .arg("--set-upstream")
            .arg(remote)
            .arg(branch)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to push: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to push: {}", stderr))
        }
    }

    pub fn pull(&self, project_name: &str, remote: &str, branch: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("pull")
            .arg(remote)
            .arg(branch)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to pull: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to pull: {}", stderr))
        }
    }

    pub fn get_remotes(&self, project_name: &str) -> Result<Vec<GitRemote>, String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("remote")
            .arg("-v")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to get remotes: {}", e))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Failed to get remotes: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let remotes: Vec<GitRemote> = stdout
            .lines()
            .filter_map(|line| {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 2 {
                    Some(GitRemote {
                        name: parts[0].to_string(),
                        url: parts[1].to_string(),
                        kind: if parts.len() > 2 { parts[2].to_string() } else { "fetch".to_string() },
                    })
                } else {
                    None
                }
            })
            .collect();

        Ok(remotes)
    }

    pub fn add_remote(&self, project_name: &str, name: &str, url: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("remote")
            .arg("add")
            .arg(name)
            .arg(url)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to add remote: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to add remote: {}", stderr))
        }
    }

    pub fn create_tag(&self, project_name: &str, tag_name: &str, message: Option<&str>) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let mut command = Command::new("git");
        command.current_dir(&project_path).arg("tag");
        
        if let Some(msg) = message {
            command.arg("-a").arg(tag_name).arg("-m").arg(msg);
        } else {
            command.arg(tag_name);
        }

        let output = command
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to create tag: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to create tag: {}", stderr))
        }
    }

    pub fn push_tags(&self, project_name: &str, remote: &str) -> Result<(), String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("push")
            .arg(remote)
            .arg("--tags")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to push tags: {}", e))?;

        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(format!("Failed to push tags: {}", stderr))
        }
    }

    pub fn get_log(&self, project_name: &str, count: usize) -> Result<Vec<GitCommit>, String> {
        let project_path = self.config.get_project_path(project_name);
        
        if !self.is_git_initialized(project_name) {
            return Err("Git repository not initialized".to_string());
        }

        let output = Command::new("git")
            .current_dir(&project_path)
            .arg("log")
            .arg(format!("--max-count={}", count))
            .arg("--oneline")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| format!("Failed to get git log: {}", e))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Failed to get git log: {}", stderr));
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let commits: Vec<GitCommit> = stdout
            .lines()
            .filter_map(|line| {
                let parts: Vec<&str> = line.splitn(2, ' ').collect();
                if parts.len() == 2 {
                    Some(GitCommit {
                        hash: parts[0].to_string(),
                        message: parts[1].to_string(),
                    })
                } else {
                    None
                }
            })
            .collect();

        Ok(commits)
    }
}

#[derive(Debug, Clone)]
pub struct GitStatus {
    pub files: Vec<GitFileStatus>,
    pub current_branch: String,
    pub has_changes: bool,
}

#[derive(Debug, Clone)]
pub struct GitFileStatus {
    pub status: String,
    pub file_path: String,
}

#[derive(Debug)]
pub struct GitRemote {
    pub name: String,
    pub url: String,
    pub kind: String,
}

#[derive(Debug)]
pub struct GitCommit {
    pub hash: String,
    pub message: String,
}